---
title: 数据库事务 - 分布式事务
date: 2021-03-02 23:18:05
categories: 
- 数据库
tags: [分布式,数据库,事务]
---


数据库事务相关
<!---more--->

## 事务

ACID特性：

- A：原子性，事务要么全部完成，要么全部失败；
- C：一致性：事务完成前后，涉及到的数据的变化一致；
- I：隔离性：不同事务不会互相影响；有时序关系；
- D：持久性：事务成功就会持久更新。

## 事务的并发控制

### 乐观锁

假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。通过版本号或者CAS机制实现。

- 版本号：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

- CAS：需要读取的内存值V，进行比较的值A，拟写入的值B。当V==A时，写入B；否则不停自旋。
   * ABA问题：如果在检查的检查值时候是A，期间被修改为B，后来又被修改为A，会误认为其没有修改过。解决：增加一个stamp，比如被修改了以后增加1，每次读取再比较预期的stamp和实际的stamp。


### 悲观锁

认为每个操作都会认为别人修改，也是传统锁的思想。MYSQL里面行锁，表锁，读锁，写锁都是悲观锁。

### 隔离级别

对应产生问题：脏读、不可重复读、幻读

1. 读未提交：一个事务可以读到另一个事务还没提交的数据；
2. 读已提交：一个事务可以读到另一个已经提交的事务的数据；
3. 可重复读：为了防止出现上面的不可重复读现象。
4. 串行化：事务按照顺序一条条执行。

1：事务A读取了事务B尚未提交的数据；

2：事务A先读取了数据，然后事务B更新了数据，事务A再次读数据时，发现已经产生了变化；

3：但是，一个事务如果进行写入，可能会改变另一个事务的查询结果。为了避免不可重复读，在事务A读取数据后，就不能对该数据进行更新。
* 解决方法：间隙锁，在行记录中加入锁，阻止新纪录的插入。


## 分布式事务

在多台服务器上进行事务。

### 2PC

由协调者收集参与真正事务集群的反馈，再根据反馈决定是提交还是终止事务。

![](https://jaroffertree.oss-cn-hongkong.aliyuncs.com/20210302010923.png)

但是如果这时候协调者宕机了，那么参与者会阻塞，一直等待协调者的回复。

这时候就需要一个高可用的系统来保证2PC的协调者在宕机后，也能根据log来恢复系统的正常运行。

### 3PC

假如2PC中的协调者宕机了，有一个参与的节点也宕机了；

这时候即使我们使用高可用手段让协调者恢复过来，其他节点也无法让协调者完成“继续/终止”事务的决定（投票）。

3PC增加了pre-commit阶段，保证在最后提交阶段前各节点状态一致；增加了超时机制：

1. vote? -> servers;
2. pre-commit -> servers;
3. do-commit -> servers

- pre-commit：在pre-commit阶段，主要是在协调者中写入了undo log和redo log；如果在此期间超时或收不到ACK，协调者会向其他server发送中断请求；

- do-commit：协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。利用第二阶段的undo log来回滚事务。但是注意的是，此时如果参与者收不到协调者的请求，也会进行事务的提交；因为在第二阶段中，pre-commit已经达成一致，认为可以提交了，所以此时参与者会认为，这个事务能成功提交的概率很大。