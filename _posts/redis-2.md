---
title: redis设计与实现读书笔记(2)--数据库结构
date: 2020-07-28 15:46:30
categories: redis
tags: [redis]
keywords: [redis]
---

redis系列第二篇，数据库文件相关。
<!---more--->

# Redis服务器中的数据库

Server结构体中包括了redisDB类型的指针（实际是个数组），保存所有的数据库实例。初始化时可以选择创建的数据库的数量。

client结构体里面也包括了RedisDB的指针，保存当前执行命令的数据库，切换数据库就是切换这个指针的指向对象。

# 数据库键空间

redisDb数据结构：

![](https://jaroffertree.oss-cn-hongkong.aliyuncs.com/20200728193300.png)

# 设置键过期时间
命令：
EXPIRE->PEXPIRE->PEXPIREAT，
EXPIREAT->PEXPIREAT

过期时间保存在过期字典中，键为某个对象的指针，值为LL类型的整数-毫秒精度的UNIX时间戳。

还可以PERSIST移除过期时间，TTL计算返回剩余的生存时间。

# 过期键的删除策略
## 定时删除
好处：对内存友好。

缺点：如果某一时刻很多键要删除，CPU压力太大，对响应造成影响。

定时器的需要用到redis中的时间事件，redis中的时间事件由无序链表实现，查找事件的复杂度为O(n)，性能一般；

## 惰性删除
取出键的时候才删除。优点：对CPU友好。

缺点是对内存不友好，如果大批量过期键不访问时用惰性删除，约等于内存泄露。

## 定期删除
上述二者的折中，每隔一段时间执行一次删除操作，并限制删除对CPU的操作时间。

难点：确定操作时长和定期频率。频率太低或操作时间太长，退化成定时删除；反之退化成惰性删除。

# redis的删除策略

## 惰性删除策略
每次get之前都会调用下面的函数对输入的key进行检查，看是否过期；过期删除，否则不做动作。
![](https://jaroffertree.oss-cn-hongkong.aliyuncs.com/20200729121856.png)

## 定期删除策略

定期删除策略函数：在规定的时间内，遍历服务器中的所欲数据库，从数据库中的过期字典中随机检查一部分键的过期时间，然后删除过期键，同时更新数据库平均TTL的值。

同时在删除的时候，还会计算删除操作所用时间，如果超时就停止处理；

# AOF/RDB/复制功能对过期键的处理
上述说的是内存中的键过期的处理方式，



# RDB持久化
## RDB文件的创建于载入
SAVE/BGSAVE:SAVE同步进行RDB文件写入保存，客户端会阻塞；BGSAVE开启子进程保存，服务器可以继续处理客户端命令。但BGSAVE/SAVE/BGWRITEAOF三个命令会不同，是为了防止竞态条件；

如果redis开启了AOF文件持久化，会优先使用AOF文件

## 间隔保存
制定配置文件，写入自动保存条件。主要是saveparams参数，包括了seconds/changes，表示过了多少时间或者发生了多少次修改，就自动写入RDB保存。

服务器还维持了dirty和lastsave属性，记录当前服务器完成了多少次修改和上次保存的时间，用来检查条件是否满足。

## RDB文件结构：

![](https://jaroffertree.oss-cn-hongkong.aliyuncs.com/20200729192003.png)

1. RDB结构
    - REDIS：RDB文件头标识，检查是否RDB文件。
    - db_version:RDB文件版本号
    - database：各个数据库的keyvalue值；
    - EOF：1字节RDB文件结束标识
    - checksum：8字节校验和，判断RDB文件是否损坏

2. database部分
    - selectDB：数据库号码标识头，用于标识后面的db_number的位置。
    - db_number:数据库号码。
    - pairs：keyvalue键值对。

3. pairs:
    - type:key-value对象类型或底层编码。比如REDIS_RDB_TYPE_STRING等。用于决定REDIS怎么读入和解析key-value数据。
    - （带有过期时间的键值对，前面还会有保存过期时间的标识头以及过期时间）
    - key:字符串键
    - value:每个type不同，value的结构也不同，大部分可以分为value的长度len和实际value的两部分。有序集合还有分数的排列。



# AOF持久化
AOF文件其实保存的就是一系列的命令，有点像日志。
## AOF命令追加
服务端执行完一个命令后，将命令送入服务端的aof_buf缓冲区中。
## AOF文件写入和同步
服务端在结束一次事件循环时，会调用flushAppendOnlyFile()，将aof缓冲区中的命令写入和保存到AOF文件中，通过配置可以设定写入和同步策略。

 - always:写入并同步；

 - everysec:上次同步时间超过1秒，就进行同步

 - no:同步由OS决定，一般情况下是OS的的缓冲区满了再将数据写入文件。

 因此，always安全性最高，同样的效率最低；no的效率最高，但是安全性较低。

 ## AOF文件载入和数据还原
 服务端启动，创建伪客户端用于执行AOF文件中的命令，从AOF文件中分析读取一条命令，使用伪客户端执行该命令。当所有命令执行完以后，结束载入，此时数据还原了。

 ## AOF重写
 随着redis的运行，AOF文件中的命令会越来越多，这时候就需要对AOF文件进行重写。

 实现就是读取现在数据库的状态，然后用对应的写入命令代替以前的多条命令。重写的时候要忽略过期的键，如果键有过期时间，过期时间也要重写。

 ## AOF后台重写
 redis单线程，如果AOF有大量命令需要重写时，会阻塞主线程。所以redis提供了子进程进行AOF重写。

 但是子进程在重写过程中，服务器可能会接收到新的命令，这时候就会出现数据不一致（保存的数据库状态不是命令执行后的状态），所以redis提供了两个缓冲区，一个是aof缓冲区，一个是aof重写缓冲区。
 1. 在使用子进程后开始使用aof重写缓冲区。如果此时服务器接收到命令，命令将不会放入aof缓冲区，而是放入aof重写缓冲区。
 2. 当子进程完成AOF重写后，想主进程发送一个信号，主进程会将aof重写缓冲区内的内容也追加写入新的AOF文件，然后将新的AOF文件替换就的AOF文件。

