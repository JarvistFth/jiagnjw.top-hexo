---
title: 操作系统 - 进程线程
date: 2021-02-23 18:44:28
categories: 
- OS
- 内存管理
tags: [OS,进程线程]
keywords: [OS,进程线程]

---

OS进程线程
<!---more--->
## 进程线程

- 进程：进程是计算机分配资源的独立单位
- 线程：线程是计算机调度资源的独立单位

进程包括：程序代码、程序要处理的数据、程序计数器PC、堆、栈、文件、网络等。

进程有独立的地址空间。

进程由PCB进行唯一表示存在。线程则由TCB结构表示。

## linux中的进程和线程

linux中通过

```C
struct task_struct{

}

```

来表示进程的所有信息。

通过slab分配器分配task_struct，在内核栈底通过thread_info结构中的task获取实际的task_struct指针。


### 进程描述符的存放

task_struct通过pid唯一表示进程。通过current_thread_info()函数获取到正在运行的进程。

### 进程状态

1. RUNNING:可运行或正在运行；
2. INTERRUPTIBLE：可中断，被阻塞，条件达成后唤醒；
3. UNINTERRUPTIBLE: 不可中断，就算收到信号也不会唤醒。用得较少；
4. STOPPED： 停止执行

一个任务通过fork()创建新进程-> 这时候task就绪，处于RUNNING状态，但还未投入运行；

调度程序通过schedule()函数，切换正在运行的任务。

当任务被抢占或等待条件后，进入阻塞态；直到再次满足运行条件时，回到就绪态。


### 进程家族

linux中的进程都是init进程的后代；每个task_struct里都有parent指针，指向父进程；然后有一个children链表，指向所有子进程。

### 进程创建

fork()创建拷贝task_struct，exec()读取可执行文件，载入地址空间。

#### fork()

linux通过clone()系统调用，fork()、vfork()等库函数最后都会用到这个系统调用，然后传入不同的标志来调用。clone()然后会调用do_fork()；

1. 创建内核栈、thread_info结构和task_struct，此时所有的值都是相同的。
2. 子进程修改一些标识信息，使其与父进程区别开来。
3. 设置进程状态为不可中断，然后更新task_struct里面的flags。
4. 调用alloc_pid()分配pid；
5. 根据传递给clone()函数的参数标志，将需要复制的数据拷贝到子进程；
6. 最后做扫尾工作和返回一个指向子进程的指针。

#### vfork()

在未实现copy on write的情况下，vfork保证子进程先运行，且与父进程共享一份地址空间。只有exec()后父进程才会继续运行。

在fork引入了copy on write后，vfork很少有用到了。


## 线程在linux中的实现

linux的实现方式是轻量级进程。线程也是一个task_struct，但是他传入的标志是CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND.

表示这两个task_struct共享打开的文件、共享文件系统信息、共享地址空间、共享信号处理函数和阻断信号。

### 内核线程

内核线程没有独立的地址空间，指向地址空间的mm指针指向null；通过kthread_create()函数创建新的内核线程。

内核线程启动后一直运行直到do_exit()调用退出。



### 进程终止

- 僵尸进程：一个子进程退出后，父进程还没有调用wait()，对子进程返回值进行处理；
- 孤儿进程：一个子进程还没有运行完，父进程就退出了。

linux中通过do_exit()进行收尾工作。

1. 调用exit_mm()释放mm_struct（地址空间）；如果没有共享的，就彻底释放；
2. sem_exit()，释放进程排队等候的IPC信号；
3. exit_file()和exit_fs()，减少文件描述符和文件系统数据的引用计数，如果引用计数为0就释放；
4. exit_notify()向父进程发送信号，给子进程重新找父进程，（没有就找init）；
5. schedule()切换到其他进程。

### 删除进程描述符

linux中，调用exit后，还没有删除进程描述符；父进程获取了子进程信息后，子进程的task_struct才释放

wait()通过wait4()调用来实现。

## 进程、线程、协程（goroutine为例）

- 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。

- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。

- 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

协程不需经过内核态到用户态的切换，线程在等待IO操作时会触发上下文切换，需要在内核态上保存上下文的环境并恢复目标线程的运行环境。协程没有内核态的切换开销较高。


### goroutine的 GMP 模型

1. G：协程控制块，GCB，主要保存函数指令、参数、任务对象、上下文切换、现场保护的寄存器等；
2. M：类似线程，所有的M都有自己的线程栈，
3. P：一个抽象的概念，类似真正的CPU，当P有任务时可以创建或唤醒一个系统线程来执行他队列里的任务。由P来调度G在M上的运行。

每次收到任务（goroutine），都会创建一个G对象，G对象保存到P的队列或者全局队列中，P去唤醒一个M,然后继续执行P;

M被唤醒，查找是否有空闲的P，如果有的话，将G对象移动到本身，然后开始执行任务；

M在执行的过程中，会有上下文切换；当发生上下文切换的时候，M把所需要保存的寄存器（SP/PC等）保存到G对象上就可以了。如果G没执行完，保存后重新挂会P的队列中。


## 进程调度

### 进程调度算法：

#### FCFS：先来先服务：

- 缺点：IO/CPU密集任务时间重叠、短时间进程可能在长时间进程后

#### SPN:短进程优先

- 缺点：长进程饥饿

#### HRRN:高响应比优先：
R=(w+s)/s w为等待时间，s为执行时间，R为响应比。

- 优点：有利于短进程，计算了等待时间，不会造成长进程饥饿
- 缺点：需要预估任务完成时间

#### Round-Robin:时间片轮询
- 缺点：额外的上下文切换开销

### linux进程调度：CFS

- Round-Robin缺点：

  1. 时间片轮询的方式，时间片太短会造成密切的上下文切换让CPU处理；时间片太长会造成交互响应；

  2. 另外IO密集型任务和CPU密集型任务存在矛盾，IO密集型不需要长的时间片，CPU密集型则需要。

CFS：完全公平调度，每个进程都将获得1/n的处理器时间；

每个进程设定了nice值，通过nice值的相对值，作为CFS中进程获取处理器运行比的权重。

nice值越低，进程能获得更高的处理器使用权重。

每次将运行的进程加入到红黑树中保存，按照vruntime进行排序，每次取出下一个的时候，取vruntime最小的那个进程进行调度运行。









